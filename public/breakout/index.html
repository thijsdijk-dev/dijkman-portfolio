<!doctype html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Breakout</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: radial-gradient(circle at top, #111827, #020617 70%);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        color: #e5e7eb;
      }
      .frame {
        width: min(96vw, 920px);
        padding: 14px;
        border-radius: 16px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.75);
        backdrop-filter: blur(4px);
      }
      .topbar {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
        font-size: 14px;
      }
      canvas {
        width: 100%;
        display: block;
        background: #020617;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.3);
      }
      .help { margin: 10px 0 0; font-size: 13px; opacity: .8; }
    </style>
  </head>
  <body>
    <main class="frame">
      <div class="topbar">
        <strong>Breakout</strong>
        <span id="hud">Score: 0 · Lives: 3</span>
      </div>
      <canvas id="game" width="900" height="560" aria-label="Breakout game"></canvas>
      <p class="help">Besturing: ← → of A/D. Druk op spatie om te starten/herstarten.</p>
    </main>

    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hud = document.getElementById('hud');

      const paddle = { w: 150, h: 14, x: 375, y: 520, speed: 8, vx: 0 };
      const ball = { x: 450, y: 500, r: 9, vx: 2.8, vy: -2.8 };
      const rows = 6, cols = 11, gap = 8, brickW = 68, brickH = 22, offsetX = 31, offsetY = 70;
      let bricks = [];
      let score = 0;
      let lives = 3;
      let running = false;
      let won = false;

      function resetBricks() {
        bricks = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            bricks.push({
              x: offsetX + c * (brickW + gap),
              y: offsetY + r * (brickH + gap),
              w: brickW,
              h: brickH,
              hp: 1,
              hue: 210 + r * 18,
            });
          }
        }
      }

      function resetBallPaddle() {
        paddle.x = (canvas.width - paddle.w) / 2;
        ball.x = canvas.width / 2;
        ball.y = paddle.y - ball.r - 2;
        ball.vx = 2.8 * (Math.random() > 0.5 ? 1 : -1);
        ball.vy = -2.8;
      }

      function resetGame() {
        score = 0;
        lives = 3;
        won = false;
        resetBricks();
        resetBallPaddle();
        running = false;
        updateHud();
      }

      function updateHud() {
        hud.textContent = `Score: ${score} · Lives: ${lives}`;
      }

      function circleRectCollision(cx, cy, cr, rx, ry, rw, rh) {
        const closestX = Math.max(rx, Math.min(cx, rx + rw));
        const closestY = Math.max(ry, Math.min(cy, ry + rh));
        const dx = cx - closestX;
        const dy = cy - closestY;
        return dx * dx + dy * dy < cr * cr;
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const b of bricks) {
          if (!b.hp) continue;
          ctx.fillStyle = `hsl(${b.hue} 85% 55%)`;
          ctx.fillRect(b.x, b.y, b.w, b.h);
          ctx.strokeStyle = 'rgba(255,255,255,.25)';
          ctx.strokeRect(b.x, b.y, b.w, b.h);
        }

        ctx.fillStyle = '#f8fafc';
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);

        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = '#fbbf24';
        ctx.fill();

        if (!running) {
          ctx.fillStyle = 'rgba(2,6,23,.72)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.font = 'bold 46px system-ui';
          ctx.fillText(won ? 'Gewonnen!' : lives <= 0 ? 'Game Over' : 'Breakout', canvas.width / 2, 240);
          ctx.font = '24px system-ui';
          ctx.fillText('Druk op spatie om te spelen', canvas.width / 2, 290);
        }
      }

      function update() {
        paddle.x += paddle.vx;
        paddle.x = Math.max(0, Math.min(canvas.width - paddle.w, paddle.x));

        if (!running) return;

        ball.x += ball.vx;
        ball.y += ball.vy;

        if (ball.x - ball.r <= 0 || ball.x + ball.r >= canvas.width) ball.vx *= -1;
        if (ball.y - ball.r <= 0) ball.vy *= -1;

        if (circleRectCollision(ball.x, ball.y, ball.r, paddle.x, paddle.y, paddle.w, paddle.h) && ball.vy > 0) {
          const hit = (ball.x - (paddle.x + paddle.w / 2)) / (paddle.w / 2);
          ball.vx = hit * 4.2;
          ball.vy = -Math.abs(ball.vy);
        }

        for (const b of bricks) {
          if (!b.hp) continue;
          if (circleRectCollision(ball.x, ball.y, ball.r, b.x, b.y, b.w, b.h)) {
            b.hp = 0;
            score += 10;
            updateHud();
            const prevX = ball.x - ball.vx;
            if (prevX < b.x || prevX > b.x + b.w) ball.vx *= -1;
            else ball.vy *= -1;
            break;
          }
        }

        if (bricks.every((b) => !b.hp)) {
          won = true;
          running = false;
        }

        if (ball.y - ball.r > canvas.height) {
          lives -= 1;
          updateHud();
          if (lives <= 0) {
            running = false;
          } else {
            resetBallPaddle();
            running = false;
          }
        }
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      function setMove(key, down) {
        if (key === 'ArrowLeft' || key.toLowerCase() === 'a') paddle.vx = down ? -paddle.speed : (paddle.vx < 0 ? 0 : paddle.vx);
        if (key === 'ArrowRight' || key.toLowerCase() === 'd') paddle.vx = down ? paddle.speed : (paddle.vx > 0 ? 0 : paddle.vx);
      }

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          if (lives <= 0 || won) resetGame();
          running = true;
          return;
        }
        setMove(e.key, true);
      });
      window.addEventListener('keyup', (e) => setMove(e.key, false));

      let touchX = null;
      canvas.addEventListener('touchstart', (e) => {
        touchX = e.touches[0].clientX;
        if (!running) running = true;
      }, { passive: true });
      canvas.addEventListener('touchmove', (e) => {
        if (touchX == null) return;
        const x = e.touches[0].clientX;
        paddle.x += (x - touchX) * 1.6;
        touchX = x;
      }, { passive: true });
      canvas.addEventListener('touchend', () => { touchX = null; }, { passive: true });

      resetGame();
      loop();
    </script>
  </body>
</html>
