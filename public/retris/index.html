<!doctype html>
<html lang="nl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Retris</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; min-height: 100vh; display: grid; place-items: center; background: radial-gradient(circle at top, #1e1e3f, #08080f 60%); font-family: Inter, system-ui, sans-serif; color: #f5f5ff; }
      .wrap { display: grid; grid-template-columns: auto 180px; gap: 18px; align-items: start; }
      canvas { background: #090915; border: 2px solid #7a5cff; border-radius: 8px; box-shadow: 0 0 30px rgba(122,92,255,.35); }
      .panel { background: rgba(17,17,32,.8); border: 1px solid #36365a; border-radius: 10px; padding: 12px; }
      h1 { margin: 0 0 12px; font-size: 1.2rem; }
      p { margin: 6px 0; font-size: .92rem; }
      .muted { opacity: .78; font-size: .82rem; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <canvas id="game" width="240" height="400"></canvas>
      <div class="panel">
        <h1>Retris</h1>
        <p>Score: <strong id="score">0</strong></p>
        <p>Level: <strong id="level">1</strong></p>
        <p>Lijnen: <strong id="lines">0</strong></p>
        <p class="muted">← → verplaatsen<br/>↑ roteren<br/>↓ sneller<br/>spatie hard drop</p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      ctx.scale(20, 20);
      const colors = [null,'#8be9fd','#bd93f9','#ff79c6','#50fa7b','#f1fa8c','#ffb86c','#ff5555'];
      const pieces = 'TJLOSZI';
      const arena = createMatrix(12, 20);
      const player = { pos: {x:0,y:0}, matrix: null, score: 0, lines: 0, level: 1 };
      let dropCounter = 0, dropInterval = 800, lastTime = 0;

      function createMatrix(w, h) { const matrix = []; while (h--) matrix.push(new Array(w).fill(0)); return matrix; }
      function createPiece(type) {
        if (type === 'T') return [[0,0,0],[1,1,1],[0,1,0]];
        if (type === 'O') return [[2,2],[2,2]];
        if (type === 'L') return [[0,3,0],[0,3,0],[0,3,3]];
        if (type === 'J') return [[0,4,0],[0,4,0],[4,4,0]];
        if (type === 'I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
        if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
        if (type === 'Z') return [[7,7,0],[0,7,7],[0,0,0]];
      }
      function collide(arena, player) {
        const [m, o] = [player.matrix, player.pos];
        for (let y = 0; y < m.length; ++y) for (let x = 0; x < m[y].length; ++x) if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
        return false;
      }
      function merge(arena, player) { player.matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) arena[y + player.pos.y][x + player.pos.x] = v; })); }
      function arenaSweep() {
        let rowCount = 1;
        outer: for (let y = arena.length - 1; y >= 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) if (arena[y][x] === 0) continue outer;
          const row = arena.splice(y, 1)[0].fill(0); arena.unshift(row); ++y;
          player.score += rowCount * 10; player.lines += 1; rowCount *= 2;
        }
      }
      function rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) for (let x = 0; x < y; ++x) [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; dir > 0 ? matrix.forEach(r => r.reverse()) : matrix.reverse(); }
      function playerDrop() {
        player.pos.y++;
        if (collide(arena, player)) { player.pos.y--; merge(arena, player); playerReset(); arenaSweep(); updateStats(); }
        dropCounter = 0;
      }
      function playerHardDrop() { while (!collide(arena, player)) player.pos.y++; player.pos.y--; playerDrop(); }
      function playerMove(dir) { player.pos.x += dir; if (collide(arena, player)) player.pos.x -= dir; }
      function playerReset() {
        player.matrix = createPiece(pieces[(Math.random() * pieces.length) | 0]);
        player.pos.y = 0;
        player.pos.x = ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);
        if (collide(arena, player)) { arena.forEach(r => r.fill(0)); player.score = 0; player.lines = 0; player.level = 1; dropInterval = 800; updateStats(); }
      }
      function playerRotate(dir) {
        const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir);
        while (collide(arena, player)) { player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; } }
      }
      function drawMatrix(matrix, offset) { matrix.forEach((row, y) => row.forEach((v, x) => { if (v !== 0) { ctx.fillStyle = colors[v]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1); } })); }
      function draw() { ctx.fillStyle = '#090915'; ctx.fillRect(0, 0, canvas.width, canvas.height); drawMatrix(arena, {x:0,y:0}); drawMatrix(player.matrix, player.pos); }
      function update(time = 0) { const delta = time - lastTime; lastTime = time; dropCounter += delta; if (dropCounter > dropInterval) playerDrop(); draw(); requestAnimationFrame(update); }
      function updateStats() {
        player.level = Math.floor(player.lines / 10) + 1;
        dropInterval = Math.max(120, 800 - (player.level - 1) * 70);
        document.getElementById('score').textContent = player.score;
        document.getElementById('lines').textContent = player.lines;
        document.getElementById('level').textContent = player.level;
      }
      document.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') playerMove(-1);
        else if (e.key === 'ArrowRight') playerMove(1);
        else if (e.key === 'ArrowDown') playerDrop();
        else if (e.key === 'ArrowUp') playerRotate(1);
        else if (e.code === 'Space') playerHardDrop();
      });
      playerReset(); updateStats(); update();
    </script>
  </body>
</html>
